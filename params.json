{"name":"Wson","tagline":"","body":"# wson [![Build Status](https://secure.travis-ci.org/tapirdata/wson.png?branch=master)](https://travis-ci.org/tapirdata/wson) [![Dependency Status](https://david-dm.org/tapirdata/wson.svg)](https://david-dm.org/tapirdata/wson) [![devDependency Status](https://david-dm.org/tapirdata/wson/dev-status.svg)](https://david-dm.org/tapirdata/wson#info=devDependencies)\r\n> A Stringifier and Parser for the WSON data-interchange format.\r\n\r\n## Usage\r\n\r\n```bash\r\n$ npm install wson\r\n```\r\n\r\nIf you have installed [node-gyp](https://www.npmjs.com/package/node-gyp) and its prerequisites, this will also install the optional package [wson-addon](https://www.npmjs.com/package/wson-addon), which provides a somewhat faster (some benchmarking shows a factors of about 2 for parsing and 1.5 for stringifiying) native C++ implementation of a WSON stringifier/parser.\r\n\r\n```js\r\nWSON = require('wson')();\r\n\r\nvar entry = {\r\n  name: \"otto\",\r\n  size: 177.3,\r\n  completed: [\"forth\", \"javascript\", \"c++\", \"haskell\"],\r\n  active: true\r\n};\r\n\r\nvar s = WSON.stringify(entry);\r\nconsole.log(s);\r\n// '{active|completed:[forth|javascript|c++|haskell]|name:otto|size:#177.3}'\r\n\r\nvar newEntry = WSON.parse(s);\r\n// equivalent to entry\r\n\r\n```\r\n## Motivation (why just another format?)\r\n\r\nWe demanded a format that:\r\n- is deterministic (stringification does not depend on key insertion order or unjustified assumptions about the js-engine).\r\n- is textual, so it can be used as a key itself.\r\n- is terse, especially does grow linearly in length when stringified recursively (`\\`-escaping grows exponentially).\r\n- is reasonably human readable.\r\n- can be parsed reasonably fast.\r\n- can handle [cyclic structures](#backrefs).\r\n- is [extensible](#custom-objects).\r\n- can parse strings that contain WSON mixed [with other stuff](#parse-partial).\r\n\r\nSince we found shortcomings in all present formats, we decided to create WSON:\r\n\r\n### WSON\r\n\r\n#### Escaping\r\n\r\nThere 8 special characters: `{`, `}`, `[`, `]`, `#`, `:`, `|`, `` ` ``. If they occur in strings the will be escaped using these counterparts:\r\n\r\n| original | escaped |\r\n|:--------:|:-------:|\r\n|   {      |   `o    |\r\n|   }      |   `c    |\r\n|   [      |   `a    |\r\n|   ]      |   `e    |\r\n|   #      |   `l    |\r\n|   :      |   `i    |\r\n|   \\|     |   `p    |\r\n|   `      |   `q    |\r\n\r\nThe special characters are choosen to be expectable rare in natural language texts to minimize the need for escaping. E.g. delimiter is `|` instead of `,`.\r\n\r\n\r\n#### Strings\r\n\r\nStrings are stringified verbatim (without quotes). If they have special characters in them, they got escaped. The empty string is stringified as `#`.\r\n\r\n###### Examples:\r\n\r\n| javascript          | WSON            |\r\n|---------------------|-----------------|\r\n| \"abc\"               | abc             |\r\n| \"say: \\\\\"hello\\\\\"\"  | say`i \"hello\"   |\r\n| \"\"                  | #               |\r\n\r\n#### Literals\r\n\r\nBooleans, `null`, `undefined` are stringified by these patterns:\r\n\r\n| javascript          | WSON            |\r\n|---------------------|-----------------|\r\n| false               | #f              |\r\n| true                | #t              |\r\n| null                | #n              |\r\n| undefined           | #u              |\r\n\r\nNumbers are stringified by `#` prepended to the number converted to a string.\r\n\r\n###### Examples:\r\n\r\n| javascript          | WSON            |\r\n|---------------------|-----------------|\r\n| 42                  | #42             |\r\n| 42.1                | #42.1           |\r\n\r\n`Date`-objects are stringified by `#d` prepended to the `valueOf`-number (i.e. the milliseconds since midnight 01 January, 1970 UTC) converted to a string.\r\n\r\n###### Examples:\r\n\r\n| javascript              | WSON            |\r\n|-------------------------|-----------------|\r\n| new Date(1400000000000) | #d1400000000000 |\r\n\r\n\r\n#### Arrays\r\n\r\nArrays are stringified by their stringified components concatenated by `|`, enclosed by `[`, `]`.\r\n\r\n| javascript              | WSON              |\r\n|-------------------------|-------------------|\r\n| []                      | []                |\r\n| [\"foo\"]                 | [foo]             |\r\n| [\"\"]                    | [#]               |\r\n| [\"foo\",true,42]         | [foo\\|#t\\|#42]    |\r\n| [\"foo\",[\"bar\",\"baz\"]]   | [foo\\|[bar\\|baz]] |\r\n\r\n#### Objects\r\n\r\nObjects are stringified by their stringified key-value pairs concatenated by `|`, enclosed by `{`, `}`.\r\nKey-value pairs are stringified this way:\r\n- If the value is `true`: just the escaped key (This is meant to be handy for set-like objects.)\r\n- Else: escaped key `:` stringified value\r\n\r\nThe pairs are sorted by key (sorting is done before escaping).\r\n\r\n\r\n| javascript               | WSON                    |\r\n|--------------------------|-------------------------|\r\n| {}                       | {}                      |\r\n| {a: \"A\", b: \"B\"}         | {a:A\\|b:B}              |\r\n| {b: \"A\", a: \"B\"}         | {a:A\\|b:B}              |\r\n| {a: true, b: true}       | {a\\|b}                  |\r\n| {a: {c: 42}, b: [3,4]}   | {a:{c:#42}\\|b:[#3\\|#4]} |\r\n| {a: \"A\", \"\": \"B\"}        | {a:A\\|#:B}              |\r\n\r\n#### Values\r\n\r\nA **value** can be any of **string**, **literal**, **array**, and **object**.\r\nNote that array components and object values are **values**, but object keys are **strings**.\r\n\r\n<a name=\"backrefs\"></a>\r\n#### Backrefs\r\n\r\nWSON is able to stringify and parse cyclic structures by means of **backrefs**. A **backref** is represented by `|` followed by a number, that says how many levels to go up. (0 resolves to the current array or objects, 1 resolves to the structure that contains the current structure and so on.)\r\n\r\n| javascript               | WSON                    |\r\n|--------------------------|-------------------------|\r\n| x = {}; x.y = x          | {y:\\|0}                 |\r\n| x = {a:[]}; x.a.push(x)  | {a:[\\|1]}               |\r\n\r\n<a name=\"custom-objects\"></a>\r\n#### Custom Objects\r\n\r\nWSON can be extended to stringify and parse **custom objects** by means of **connectors**.\r\n\r\nA **connector** is used to stringify a **custom object** by:\r\n- `by`: the objects's constructor. Only objects with exactly that constructor use this **connector** to stringify.\r\n- `split`: a function of `obj` that returns an array of arguments `args` that can be used to recreate `obj`.\r\n\r\nIf `split` is ommited, `obj` must provide a method `__wsonsplit__` that returns `args`.\r\n\r\nA **connector** is used to create a **custom object** by:\r\n- `create`: a function that takes an array of arguments `args` to create the object `obj`.\r\n\r\nAlternatively these functions may be used to use 2-stage creation:\r\n- `precreate`: a function that creates the (empty) object `obj`.\r\n- `postcreate`: a function that takes `obj` and `args` to populate `obj`.\r\n\r\nIf no `create` is specified, missing `precreate` and `postcreate` are just created by using the constructor `by`.\r\n\r\nAn extended WSON stringifier/parser is created by passing a `connectors` option to `wson`. `connectors` should by a object that maps **cname** keys to **connector** objects. If a value is given as a function `Foo` the **connector** is constructed as `{by: Foo}`.\r\n\r\nThe WSON representation of a **custom object** is:\r\n\r\n  `[:` **cname** (list of args, each prepended by `|`) `]`\r\n\r\n###### Examples:\r\n\r\nProvide a `__wsonsplit__` method:\r\n```js\r\nvar wson = require('wson');\r\n\r\nvar Point = function(x, y) {this.x=x; this.y=y; }\r\nPoint.prototype.__wsonsplit__ = function() {return [this.x, this.y]; }\r\n\r\nvar WSON = wson({connectors: {Point: Point}});\r\n\r\nvar point1 = new Point(3, 4);\r\n\r\nvar s = WSON.stringify(point1);\r\nconsole.log('s=', s); // [:Point|#3|#4]\r\nvar point2 = WSON.parse(s);\r\n```\r\n\r\nOr equivalently specify `split` explicitly:\r\n```js\r\nvar wson = require('wson');\r\n\r\n\r\nvar Point = function(x, y) {this.x=x; this.y=y}\r\n\r\nvar WSON = wson({connectors: {\r\n  Point: {\r\n    by: Point,\r\n    split: function(point) {return [point.x, point.y]; }\r\n  }\r\n}});\r\n\r\nvar point1 = new Point(3, 4);\r\nvar s = WSON.stringify(point1);\r\nconsole.log('s=', s); // [Point:#3|#4]\r\nvar point2 = WSON.parse(s);\r\n```\r\n\r\nSpecify `split` and `postcreate` (use default `precreate`):\r\n```js\r\nvar wson = require('wson');\r\n\r\nvar Point = function(x, y) {this.x=x; this.y=y}\r\n\r\nvar WSON = wson({connectors: {\r\n  Point: {\r\n    by: Point,\r\n    // reverse order of args for some strange reason\r\n    split: function(point) {return [point.y, point.x]; },\r\n    postcreate: function(point, args) {Point.call(point, args[1], args[0]); }\r\n  }\r\n}});\r\n\r\nvar point1 = new Point(3, 4);\r\nvar s = WSON.stringify(point1);\r\nconsole.log('s=', s); // [Point:#4|#3]\r\nvar point2 = WSON.parse(s);\r\n```\r\n\r\nAlternately you could specify `create` (with the lack of ability to use the constructor with `call` and `apply`. And: see Corner cases below):\r\n```js\r\nvar WSON = wson({connectors: {\r\n  Point: {\r\n    by: Point,\r\n    split: function(point) {return [point.y, point.x]; },\r\n    create: function(args) {return new Point(args[1], args[0]); }\r\n  }\r\n}});\r\n```\r\n\r\n###### Corner cases:\r\n\r\nYou *can* use together **backrefs** and **custom objects**. For example this will work:\r\n\r\n```js\r\nvar pointCyc = new Point(5); // leave 'y' undefined for now\r\nvar points = [pointCyc, pointCyc]\r\npointCyc.y = points;\r\nvar s = WSON.stringify(pointCyc);\r\n```\r\nprovided that:\r\n- You use 2-stage creation (don't use `create`).\r\n- `postcreate` (or your constructor `by` from which `postcreate` is auto-created) does return that object which has been passed in.\r\n\r\n## API\r\n\r\n#### var WSON = wson(options)\r\n\r\nCreates a new WSON processor. Recognized options are:\r\n- `useAddon` (boolean, default: `undefined`):\r\n  - `false`: An installed `wson-addon` is ignored.\r\n  - `true`: The addon is forced. An exception is thrown if the addon is missing.\r\n  - `undefined`: The addon is used when it is available.\r\n- `version` (number, default: `undefined`): the WSON-version to create the processor for. This document describes version 1. If this is `undefined`, the last available version is used.\r\n- `connectors` (optional): an object that maps **cnames** to [connectors](#custom-objects).\r\n\r\n#### WSON.stringify(val, options)\r\n\r\nReturns the WSON representation of `val`.\r\n- `options`:\r\n  - `haverefCb` (`function(val)`): a function that can create backrefs outside of `val`. It should return an integer >= 0 for a preexistent enclosing object, otherwise `null`. I.e. `haverefCb` and `backrefCb` are expected to be inverses. \r\n\r\n#### WSON.parse(str, options)\r\n\r\nReturns the value of the WSON string `str`. If `str` is ill-formed, a `ParseError` will be thrown.\r\n- `options`:\r\n  - `backrefCb` (`function(refIdx)`): a function that can resolve backrefs outside of the item that corresponds to `str`. `refIdx=0` will refer to next enclosing object.\r\n\r\n<a name=\"parse-partial\"></a>\r\n#### WSON.parsePartial(str, options)\r\n\r\nParse a string with embedded WSON strings by intercepting the WSON lexer/parser.\r\n\r\n- `str`: The string to be parsed.\r\n- `options`:\r\n  - `howNext`: determines how the next chunk should be handled. This may be an array `[nextRaw, skip]` or just boolean `nextRaw`. `skip` is the number of characters to be skipped first (Say, they have been proceeded by other means). Then, if `nextRaw` is:\r\n    - `true`, just the lexer is to be used. The next `value` passed to `cb` will be either:\r\n      - One of the special characters `{`, `}`, `[`, `]`, `#`, `:`, `|`. This is signaled by `isValue == false`.\r\n      - A non-empty string that results by unescaping untill the next special character. This is signaled by `isValue == true`.\r\n    - `false`, an attempt to parse is requested. The next `value` passed to `cb` will be either:\r\n      - One of the special characters `}`, `]`, `:`, `|` that may not start a valid WSON string. This is signaled by `isValue == false`.\r\n      - The value of the next WSON string. This is signaled by `isValue == true`. If this sub-string is ill-formed, a `ParseError` will be thrown.\r\n    Any other value of `howNext` will cause `parsePartial` to stop immediately with a result of `false`.\r\n  - `cb` (`function(isValue, value, pos)`): This callback reports the next chunk according to `howNext`. `pos` will be set to the next (yet unparsed) position in `str`. The return value of `cb` is used as `howNext` for next parsing step.\r\n  - `backrefCb` (`function(refIdx)`): a function that can resolve backrefs outside of the item that corresponds to `str`. `refIdx=0` will refer to next enclosing object.\r\n\r\nIf `parseNext` happens to parse the complete `str`, it will return `true`.\r\n\r\n#### WSON.escape(str)\r\n\r\nReturns `str` with the special characters replaced by their corresponding escape sequences.\r\n\r\n#### WSON.unescape(str)\r\n\r\nReturns `str` with encountered escape sequence replaced by their counterparts. If `str` contains invalid escape sequences, a `ParseError` will be thrown.\r\n\r\n#### WSON.getTypeid(value)\r\n\r\nReturns a numeric type-id of `value`. This function is exposed as it may be usefull for extending WSON.\r\n\r\n|  value                 | typeid |\r\n|:----------------------:|:------:|\r\n|  `undefined`           |   1    |\r\n|  `null`                |   2    |\r\n|  `Boolean`             |   4    |\r\n|  `Number` (`NaN`, too) |   8    |\r\n|  `Date`                |   16   |\r\n|  `String`              |   20   |\r\n|  `Array`               |   24   |\r\n|   other `Object`       |   32   |\r\n\r\n\r\n#### WSON.connectorOfCname(cname)\r\n\r\nReturns the normalized [connector](#custom-objects) for **cname** (or `null` if none is found).\r\n\r\n#### WSON.connectorOfValue(value)\r\n\r\nReturns the normalized [connector](#custom-objects) for `value` (or `null` if none is found).\r\n\r\n#### wson.ParseError\r\n\r\nThis may be thrown by `WSON.parse` and `WSON.parsePartial`. It provides these fields:\r\n- `s`: the original ill-formed string.\r\n- `pos`: the position in `s` where passing has stumbled.\r\n- `cause`: some textual description of what caused to reject the string `s`.\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}